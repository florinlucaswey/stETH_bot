# ChatGPT Rules

## Angular best practices
- Prefer standalone components with route-level providers (`provideHttpClient`, `provideRouter`); avoid new NgModules unless interoperating with legacy code.
- Default to `ChangeDetectionStrategy.OnPush`, keep templates pure, and lean on `async` pipe/signals instead of manual subscriptions; clean up RxJS with `takeUntilDestroyed()`.
- Keep components small and focused; push data access and side effects into injectables (services/stores) and reuse them via DI.
- SSR-friendly by guarding browser-only APIs (`isPlatformBrowser`, feature flags) and favoring pure functions; avoid direct DOM access.
- Strongly type `HttpClient` calls, use typed forms (`NonNullableFormBuilder`/`FormBuilder.nonNullable`), and keep shared validators in `shared/validators`.

## Folder structure hints
- Root Angular app lives in `eth-steth-dashboard/src/app`; add new features under `src/app/features/<domain>/` with their own routes/entry component.
- Shared UI primitives, pipes, and directives belong in `src/app/shared/`; avoid feature-to-feature imports that bypass `shared`.
- Cross-cutting singletons (auth/logging/http config) stay in `src/app/core/`; keep side-effectful initialization isolated here.
- Keep API/data contracts and clients grouped by domain (e.g., `src/app/shared/data/<domain>/` or `features/<domain>/data/`).
- Maintain SSR/server bits under `src/` root (`main.server.ts`, Express handlers) and keep browser-only code out of server entrypoints.

## TypeScript conventions
- Keep strict mode on and avoid `any`; use `unknown` + type narrowing when needed and document unavoidable escapes.
- Prefer `type` aliases for shapes/unions and reserve `interface` for public contracts or extendable abstractions; favor named exports over defaults.
- Mark immutables as `readonly`, use `const`/`as const` for literal configs, and keep discriminated unions for stateful models.
- Keep function signatures small; pass structured parameter objects when several values travel together, and co-locate types next to their owning feature.
- Observable vars end with `$`; prefer `signal`/`computed` for component state when practical and bridge to RxJS with `toSignal`/`toObservable`.

## Module routing patterns
- Define top-level routes in `app.routes.ts` and feature-local routes in `features/<domain>/<domain>.routes.ts`; always type with `Routes`.
- Lazy load standalone features/components:
  ```ts
  export const routes: Routes = [
    {
      path: 'portfolio',
      loadComponent: () =>
        import('./features/portfolio/portfolio.component').then(m => m.PortfolioComponent),
      providers: [providePortfolioStore()],
    },
  ];
  ```
- Use layout/shell components with `children` for nested areas; add `pathMatch: "full"` on redirects and a final wildcard to a not-found screen.
- Keep guards/resolvers reusable and attach them per route; avoid global providers unless truly app-wide concerns.
- Prefer route data for config (titles, feature flags) and typed navigation (`NavigationExtras`) for programmatic routing.
